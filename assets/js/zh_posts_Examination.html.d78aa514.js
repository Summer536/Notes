"use strict";(self.webpackChunkvuepress=self.webpackChunkvuepress||[]).push([[4696],{1155:(s,n,l)=>{l.r(n),l.d(n,{comp:()=>t,data:()=>p});var a=l(641);const i={},t=(0,l(6262).A)(i,[["render",function(s,n){return(0,a.uX)(),(0,a.CE)("div",null,n[0]||(n[0]=[(0,a.Fv)('<h1 id="examination" tabindex="-1"><a class="header-anchor" href="#examination"><span>Examination</span></a></h1><h2 id="一-0822-海光" tabindex="-1"><a class="header-anchor" href="#一-0822-海光"><span>一. 0822-海光</span></a></h2><h3 id="单选题" tabindex="-1"><a class="header-anchor" href="#单选题"><span>单选题</span></a></h3><ol><li><p>如何解决过拟合问题？</p><ul><li>A. 增加数据集</li><li>B. 增加模型复杂度</li><li>C. <strong>增加正则化</strong></li><li>D. 提高学习率</li></ul></li><li><p>几大排序中哪个平均和最坏复杂度都是O(nlogn)？</p><ul><li>A. 快速排序</li><li>B. 归并排序</li><li>C. <strong>堆排序</strong></li><li>D. 希尔排序</li></ul></li><li><p>无权图两节点的最短路径通常用什么方法？</p><ul><li>A. 深度优先搜索（DFS）</li><li>B. <strong>广度优先搜索（BFS）</strong></li><li>C. Dijkstra算法</li><li>D. 贝尔曼-福特算法（Bellman-Ford）</li></ul></li><li><p>哈希表的插入的复杂度是？</p><ul><li>A. <strong>O(1)</strong></li><li>B. O(logn)</li><li>C. O(n)</li><li>D. O(nlogn)</li></ul></li><li><p>算子融合的目的是？</p><p><strong>减少kernel启动开销，提升内存复用率</strong></p></li><li><p>Ping的协议是？</p><ul><li>A. <strong>ICMP</strong></li><li>B. TCP</li><li>C. UDP</li><li>D. ARP</li></ul></li><li><p>HTTPS的安全性主要来自于？</p><ul><li>A. 对称加密</li><li>B. 非对称加密</li><li>C. <strong>混合加密以及验证</strong></li><li>D. 哈希加密（MD5）</li></ul></li><li><p>以下哪种函数不能被设为虚函数？</p><ul><li>A. 纯虚函数</li><li>B. <strong>静态成员函数</strong></li><li>C. 普通成员函数</li><li>D. 析构函数</li></ul></li><li><p>在大型数据上取Top-K个数据，下列方法复杂度最低的是？</p><ul><li>A. <strong>建立小顶堆，然后取K个堆顶</strong></li><li>B. 快速排序，然后取前K个</li><li>C. 归并排序，然后取前K个</li><li>D. 冒泡排序，然后取前K个</li></ul></li></ol><h3 id="多选题" tabindex="-1"><a class="header-anchor" href="#多选题"><span>多选题</span></a></h3><ol><li><p>GEMM的说法正确的是？</p><ul><li>A. gemm满足乘法交换律 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∗</mo><mi>B</mi><mo>=</mo><mi>B</mi><mo>∗</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A*B=B*A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></li><li>B. <strong>gemm满足乘法结合律 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>∗</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>C</mi><mo>=</mo><mi>A</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>B</mi><mo>∗</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A*B)*C=A*(B*C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></strong></li><li>C. <strong>gemm的A矩阵列数必须=B矩阵行数</strong></li><li>D. <strong>gemm的计算复杂度是 O(n³)，当矩阵为 n×n 时</strong></li></ul></li><li><p>以下哪些属于内核态的功能？</p><ul><li>A. <strong>进程管理</strong></li><li>B. <strong>内存管理</strong></li><li>C. <strong>系统管理</strong></li><li>D. 用户显示绘制</li></ul></li><li><p>以下哪些是提升cache的技术？</p><ul><li>A. <strong>预取</strong></li><li>B. <strong>非缓存阻塞</strong></li><li>C. <strong>增大内存带宽</strong></li><li>D. <strong>增大内存容量</strong></li></ul></li><li><p>以下哪些是L1L2L3的特征？</p><ul><li>A. 全部是全相连</li><li>B. <strong>越靠近核心，容量越小，速度越快</strong></li><li>C. <strong>L3cache是所有核心共享的</strong></li><li>D. <strong>L1cache是组相联映射</strong></li></ul></li><li><p>以下哪些属于分治策略？</p><ul><li>A. <strong>快速排序</strong></li><li>B. <strong>归并排序</strong></li><li>C. <strong>二分查找</strong></li><li>D. 动态规划</li></ul></li></ol><h3 id="判断题" tabindex="-1"><a class="header-anchor" href="#判断题"><span>判断题</span></a></h3><ol><li><p>频繁切换线程会影响资源调度，导致计算速度变慢。✅</p></li><li><p>Batch Normalization 可以提升训练稳定性以及减少梯度爆炸。✅</p><p>Batch Normalization（批归一化）通过对每层输入进行归一化（均值为0，方差为1），缓解了内部协变量偏移（Internal Covariate Shift），使得网络更稳定，允许使用更大的学习率，并有助于缓解梯度消失/爆炸问题。</p></li><li><p>FMA（Fused Multiply-Add），可以提升浮点数的计算精度和速度。✅</p><p>速度：减少指令数，提高吞吐。<br> 精度：中间结果不进行舍入，只在最后一步舍入，比先乘后加（两次舍入）更精确。</p></li><li><p>开启-o3 -ffast-math可以保证数字严格应用IEEE754标准。❌</p><p>-ffast-math：放松 IEEE754 兼容性，允许重排浮点运算（如 (a+b)+c → a+(b+c)），忽略 NaN、Inf 处理等，以换取性能。</p></li><li><p>DNS可以解析IP。❌</p><p>DNS 是 Domain Name System，作用是将域名解析为 IP 地址（正向解析），或将 IP 解析为域名（反向解析，PTR 记录）。</p></li><li><p>AVL平衡树的平衡因子只能是0或1。❌</p><p>平衡因子是左子树高度减去右子树高度，平衡因子只能是-1、0、1。</p></li><li><p>explicit关键字修饰的量一定不能被隐式转换。✅</p></li><li><p>SRAM存储的数据在断电后会丢失。✅</p></li></ol><h3 id="简答题" tabindex="-1"><a class="header-anchor" href="#简答题"><span>简答题</span></a></h3><ol><li><p>简述快速排序的思想：</p><p>快速排序是一种<strong>分治算法</strong>，通过选择一个基准元素，将数组分为两个子数组，其中一个子数组的所有元素都小于基准元素，另一个子数组的所有元素都大于基准元素。然后对两个子数组递归地进行快速排序。</p></li><li><p>寄存器重命名技术之一是WAR，另一个是（）</p><p><strong>WAW</strong></p></li><li><p>十进制数字1101转为十六进制为？（答案请包含前缀0x）</p><p><strong>0x44D</strong></p></li><li><p>将循环体中计算不变的量提到循环体外的操作称为：</p><p><strong>循环不变量外提（Loop Invariant Code Motion）</strong> 是一种常见的编译器优化技术，指将循环体内不随循环迭代变化的计算（如表达式、函数调用等）移动到循环外部，以减少重复计算，提升程序性能。</p></li><li><p>C++中修饰常量的关键字是：</p><p><strong>const</strong></p></li><li><p>CNN的迟化策略包括最大值迟化和（）</p><p><strong>平均迟化</strong></p></li></ol>',10)]))}]]),p=JSON.parse('{"path":"/zh/posts/Examination.html","title":"Examination","lang":"zh-CN","frontmatter":{"title":"Examination","date":"2025-08-22T00:00:00.000Z","readingTime":300,"category":["笔记"],"tag":["GPU优化"],"isOriginal":true,"description":"Examination 一. 0822-海光 单选题 如何解决过拟合问题？ A. 增加数据集 B. 增加模型复杂度 C. 增加正则化 D. 提高学习率 几大排序中哪个平均和最坏复杂度都是O(nlogn)？ A. 快速排序 B. 归并排序 C. 堆排序 D. 希尔排序 无权图两节点的最短路径通常用什么方法？ A. 深度优先搜索（DFS） B. 广度优先搜...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Examination\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T03:04:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GYQ\\",\\"url\\":\\"https://github.com/Summer536\\"}]}"],["meta",{"property":"og:url","content":"https://your-domain.com/Notes/zh/posts/Examination.html"}],["meta",{"property":"og:site_name","content":"GYQ的博客"}],["meta",{"property":"og:title","content":"Examination"}],["meta",{"property":"og:description","content":"Examination 一. 0822-海光 单选题 如何解决过拟合问题？ A. 增加数据集 B. 增加模型复杂度 C. 增加正则化 D. 提高学习率 几大排序中哪个平均和最坏复杂度都是O(nlogn)？ A. 快速排序 B. 归并排序 C. 堆排序 D. 希尔排序 无权图两节点的最短路径通常用什么方法？ A. 深度优先搜索（DFS） B. 广度优先搜..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T03:04:48.000Z"}],["meta",{"property":"article:tag","content":"GPU优化"}],["meta",{"property":"article:published_time","content":"2025-08-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T03:04:48.000Z"}]]},"git":{"createdTime":1755831888000,"updatedTime":1755831888000,"contributors":[{"name":"yqgao","username":"yqgao","email":"gaoyuqing536@gmail.com","commits":1,"url":"https://github.com/yqgao"}]},"readingTime":{"minutes":3.98,"words":1195},"filePathRelative":"zh/posts/Examination.md","excerpt":"\\n<h2>一. 0822-海光</h2>\\n<h3>单选题</h3>\\n<ol>\\n<li>\\n<p>如何解决过拟合问题？</p>\\n<ul>\\n<li>A. 增加数据集</li>\\n<li>B. 增加模型复杂度</li>\\n<li>C. <strong>增加正则化</strong></li>\\n<li>D. 提高学习率</li>\\n</ul>\\n</li>\\n<li>\\n<p>几大排序中哪个平均和最坏复杂度都是O(nlogn)？</p>\\n<ul>\\n<li>A. 快速排序</li>\\n<li>B. 归并排序</li>\\n<li>C. <strong>堆排序</strong></li>\\n<li>D. 希尔排序</li>\\n</ul>\\n</li>\\n<li>\\n<p>无权图两节点的最短路径通常用什么方法？</p>\\n<ul>\\n<li>A. 深度优先搜索（DFS）</li>\\n<li>B. <strong>广度优先搜索（BFS）</strong></li>\\n<li>C. Dijkstra算法</li>\\n<li>D. 贝尔曼-福特算法（Bellman-Ford）</li>\\n</ul>\\n</li>\\n<li>\\n<p>哈希表的插入的复杂度是？</p>\\n<ul>\\n<li>A. <strong>O(1)</strong></li>\\n<li>B. O(logn)</li>\\n<li>C. O(n)</li>\\n<li>D. O(nlogn)</li>\\n</ul>\\n</li>\\n<li>\\n<p>算子融合的目的是？</p>\\n<p><strong>减少kernel启动开销，提升内存复用率</strong></p>\\n</li>\\n<li>\\n<p>Ping的协议是？</p>\\n<ul>\\n<li>A. <strong>ICMP</strong></li>\\n<li>B. TCP</li>\\n<li>C. UDP</li>\\n<li>D. ARP</li>\\n</ul>\\n</li>\\n<li>\\n<p>HTTPS的安全性主要来自于？</p>\\n<ul>\\n<li>A. 对称加密</li>\\n<li>B. 非对称加密</li>\\n<li>C. <strong>混合加密以及验证</strong></li>\\n<li>D. 哈希加密（MD5）</li>\\n</ul>\\n</li>\\n<li>\\n<p>以下哪种函数不能被设为虚函数？</p>\\n<ul>\\n<li>A. 纯虚函数</li>\\n<li>B. <strong>静态成员函数</strong></li>\\n<li>C. 普通成员函数</li>\\n<li>D. 析构函数</li>\\n</ul>\\n</li>\\n<li>\\n<p>在大型数据上取Top-K个数据，下列方法复杂度最低的是？</p>\\n<ul>\\n<li>A. <strong>建立小顶堆，然后取K个堆顶</strong></li>\\n<li>B. 快速排序，然后取前K个</li>\\n<li>C. 归并排序，然后取前K个</li>\\n<li>D. 冒泡排序，然后取前K个</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}')},6262:(s,n)=>{n.A=(s,n)=>{const l=s.__vccOpts||s;for(const[s,a]of n)l[s]=a;return l}}}]);